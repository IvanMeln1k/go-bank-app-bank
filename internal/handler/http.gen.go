// Package handler provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package handler

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Account defines model for Account.
type Account struct {
	Id    openapi_types.UUID `json:"id"`
	Money int32              `json:"money"`
}

// AuthSchema defines model for AuthSchema.
type AuthSchema struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// CashoutRequest defines model for CashoutRequest.
type CashoutRequest struct {
	Amount int32 `json:"amount"`
}

// DepositRequest defines model for DepositRequest.
type DepositRequest struct {
	Amount int32 `json:"amount"`
}

// Message defines model for Message.
type Message struct {
	Message string `json:"message"`
}

// ReturnId defines model for ReturnId.
type ReturnId struct {
	Id openapi_types.UUID `json:"id"`
}

// ReturnToken defines model for ReturnToken.
type ReturnToken struct {
	Token string `json:"token"`
}

// TransferInfo defines model for TransferInfo.
type TransferInfo struct {
	Amount int32              `json:"amount"`
	To     openapi_types.UUID `json:"to"`
}

// User defines model for User.
type User struct {
	Email    openapi_types.Email `json:"email"`
	Id       openapi_types.UUID  `json:"id"`
	Name     string              `json:"name"`
	Patronyc string              `json:"patronyc"`
	Surname  string              `json:"surname"`
	Verified bool                `json:"verified"`
}

// UserWithPassword defines model for UserWithPassword.
type UserWithPassword struct {
	Email    openapi_types.Email `json:"email"`
	Name     string              `json:"name"`
	Password string              `json:"password"`
	Patronyc string              `json:"patronyc"`
	Surname  string              `json:"surname"`
}

// CashOutParams defines parameters for CashOut.
type CashOutParams struct {
	XMachineId openapi_types.UUID `form:"x-machine-id" json:"x-machine-id"`
}

// DepositParams defines parameters for Deposit.
type DepositParams struct {
	XMachineId openapi_types.UUID `form:"x-machine-id" json:"x-machine-id"`
}

// VerifyEmailParams defines parameters for VerifyEmail.
type VerifyEmailParams struct {
	Token string `form:"token" json:"token"`
}

// CashOutJSONRequestBody defines body for CashOut for application/json ContentType.
type CashOutJSONRequestBody = CashoutRequest

// DepositJSONRequestBody defines body for Deposit for application/json ContentType.
type DepositJSONRequestBody = DepositRequest

// TransferJSONRequestBody defines body for Transfer for application/json ContentType.
type TransferJSONRequestBody = TransferInfo

// SignInJSONRequestBody defines body for SignIn for application/json ContentType.
type SignInJSONRequestBody = AuthSchema

// SignUpJSONRequestBody defines body for SignUp for application/json ContentType.
type SignUpJSONRequestBody = UserWithPassword

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /api/v1/accounts)
	GetAllAccounts(ctx echo.Context) error

	// (POST /api/v1/accounts)
	CreateAccount(ctx echo.Context) error

	// (DELETE /api/v1/accounts/{accountId})
	DeleteAccount(ctx echo.Context, accountId openapi_types.UUID) error

	// (GET /api/v1/accounts/{accountId})
	GetAccountInfo(ctx echo.Context, accountId openapi_types.UUID) error

	// (PUT /api/v1/accounts/{accountId}/cashOut)
	CashOut(ctx echo.Context, accountId openapi_types.UUID, params CashOutParams) error

	// (PUT /api/v1/accounts/{accountId}/deposit)
	Deposit(ctx echo.Context, accountId openapi_types.UUID, params DepositParams) error

	// (PUT /api/v1/accounts/{accountId}/transfer)
	Transfer(ctx echo.Context, accountId openapi_types.UUID) error

	// (GET /auth/me)
	GetMe(ctx echo.Context) error

	// (POST /auth/resend-verify)
	ResendVerify(ctx echo.Context) error

	// (POST /auth/sign-in)
	SignIn(ctx echo.Context) error

	// (POST /auth/sign-up)
	SignUp(ctx echo.Context) error

	// (GET /auth/verify-email)
	VerifyEmail(ctx echo.Context, params VerifyEmailParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAllAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAllAccounts(ctx)
	return err
}

// CreateAccount converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAccount(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAccount(ctx)
	return err
}

// DeleteAccount converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", ctx.Param("accountId"), &accountId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAccount(ctx, accountId)
	return err
}

// GetAccountInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccountInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", ctx.Param("accountId"), &accountId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAccountInfo(ctx, accountId)
	return err
}

// CashOut converts echo context to params.
func (w *ServerInterfaceWrapper) CashOut(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", ctx.Param("accountId"), &accountId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{"machine"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CashOutParams

	if cookie, err := ctx.Cookie("x-machine-id"); err == nil {

		var value openapi_types.UUID
		err = runtime.BindStyledParameterWithOptions("simple", "x-machine-id", cookie.Value, &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationCookie, Explode: true, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-machine-id: %s", err))
		}
		params.XMachineId = value

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument x-machine-id is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CashOut(ctx, accountId, params)
	return err
}

// Deposit converts echo context to params.
func (w *ServerInterfaceWrapper) Deposit(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", ctx.Param("accountId"), &accountId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{"machine"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DepositParams

	if cookie, err := ctx.Cookie("x-machine-id"); err == nil {

		var value openapi_types.UUID
		err = runtime.BindStyledParameterWithOptions("simple", "x-machine-id", cookie.Value, &value, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationCookie, Explode: true, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-machine-id: %s", err))
		}
		params.XMachineId = value

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument x-machine-id is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Deposit(ctx, accountId, params)
	return err
}

// Transfer converts echo context to params.
func (w *ServerInterfaceWrapper) Transfer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", ctx.Param("accountId"), &accountId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Transfer(ctx, accountId)
	return err
}

// GetMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetMe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMe(ctx)
	return err
}

// ResendVerify converts echo context to params.
func (w *ServerInterfaceWrapper) ResendVerify(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"user"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ResendVerify(ctx)
	return err
}

// SignIn converts echo context to params.
func (w *ServerInterfaceWrapper) SignIn(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SignIn(ctx)
	return err
}

// SignUp converts echo context to params.
func (w *ServerInterfaceWrapper) SignUp(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SignUp(ctx)
	return err
}

// VerifyEmail converts echo context to params.
func (w *ServerInterfaceWrapper) VerifyEmail(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params VerifyEmailParams
	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.VerifyEmail(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts", wrapper.GetAllAccounts)
	router.POST(baseURL+"/api/v1/accounts", wrapper.CreateAccount)
	router.DELETE(baseURL+"/api/v1/accounts/:accountId", wrapper.DeleteAccount)
	router.GET(baseURL+"/api/v1/accounts/:accountId", wrapper.GetAccountInfo)
	router.PUT(baseURL+"/api/v1/accounts/:accountId/cashOut", wrapper.CashOut)
	router.PUT(baseURL+"/api/v1/accounts/:accountId/deposit", wrapper.Deposit)
	router.PUT(baseURL+"/api/v1/accounts/:accountId/transfer", wrapper.Transfer)
	router.GET(baseURL+"/auth/me", wrapper.GetMe)
	router.POST(baseURL+"/auth/resend-verify", wrapper.ResendVerify)
	router.POST(baseURL+"/auth/sign-in", wrapper.SignIn)
	router.POST(baseURL+"/auth/sign-up", wrapper.SignUp)
	router.GET(baseURL+"/auth/verify-email", wrapper.VerifyEmail)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tlKpsNZm6/8BAAD//9VUwpnANQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
